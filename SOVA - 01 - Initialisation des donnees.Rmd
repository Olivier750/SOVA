---
title: "SOVA"
author: "SOVA"
date: "29 mars 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Initialisation du projet

## Installation des packages
* readr : The goal of 'readr' is to provide a fast and friendly way to read rectangular data (like 'csv', 'tsv', and 'fwf').  
It is designed to flexibly parse many types of data found in the wild, while still cleanly failing when data unexpectedly changes.
* RSQLite : Embeds the 'SQLite' database engine in R and provides an interface compliant with the 'DBI' package. The source for the 'SQLite' engine (version 3.8.8.2) is included.
* stringr
* sqldf

```{r echo=FALSE, warning=FALSE}
packages <- c("readr", "RSQLite", "stringr", "sqldf")
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
  install.packages(setdiff(packages, rownames(installed.packages())))  
}
```

## Initialisation du répertoire de travail
```{r warning=FALSE}
setwd("C:/SOVA")
```

## Suppression des variables
```{r warning=FALSE}
rm(list = ls())
```

## Chargement des librairies
* readr
* RSQLite
* stringr
* sqldf
```{r echo=FALSE, warning=FALSE}
library("readr")
library("RSQLite")
library("stringr")
library("sqldf")
```

## Création de la base de données
* Chargement du driver SQLite
* Création de la connection à la base de données sovadb.sqlite
* Activation des extensions de SQLite
* Spatialisation de la base de données

```{r echo=FALSE, warning=FALSE}
sqldrv <- dbDriver("SQLite")

con <- dbConnect(sqldrv, dbname = "Database\\SOVA_db.sqlite", loadable.extensions = TRUE)

dbSendQuery(conn = con, "SELECT load_extension('mod_spatialite')")

dbSendQuery(conn = con, "SELECT InitSpatialMetaData()")
```

***
#Chargement des données

## Chargements des coordonnées GPS des voies
Test de l'existence de la table *lignes_tmp* (si elle existe, on la détruit et on la recrée)
La table *lignes_tmp* contient les données GPS brutes.

```{r echo=FALSE, warning=FALSE}
if (RSQLite::dbExistsTable(conn = con, "lignes_tmp") == TRUE)
{
  RSQLite::dbRemoveTable(conn = con, "lignes_tmp")
}

# Creation d'une table temporaire qui va recevoir les données GPS
RSQLite::dbSendQuery(conn = con, statement = read_file('Scripts\\01-Create Table lignes_tmp.sql'))
```


Chargement du fichier basegeometrie.rds dans la table lignes_tmp
```{r echo=FALSE, warning=FALSE}
MyFile <- paste0(getwd(),"/Datasources/basegeometrie.rds")
A <- readRDS(MyFile)
dbWriteTable(conn = con, name="lignes_tmp", A, row.names=FALSE, append=TRUE)

rm(A)
rm(MyFile)
```

Suppression des données au dela de 118 kilomètres (hors ile de france)
```{r echo=FALSE, warning=FALSE}
dbSendQuery(conn = con, statement = read_file('Scripts\\02-Suppression données hors IdF.sql'))
```




Ajout de 2 colonnes (LIGNE2 et LIGNE_VOIE)
```{r echo=FALSE, warning=FALSE}
#Ajout d'une colonne LIGNE2 qui contiendra la colonne LIGNE nettoyé
dbSendQuery(conn = con, statement = read_file('Scripts\\03-Ajouter une colonne.sql'))
dbSendQuery(conn = con, statement = read_file('Scripts\\04-Ajouter une colonne.sql'))
```

Mise à jour des colonnes (LIGNE2 et LIGNE_VOIE)
```{r echo=FALSE, warning=FALSE}
#Mise a jour de la colonne LIGNE2
dbSendQuery(conn = con, statement = read_file('Scripts\\05-MAJ colonne.sql'))
```


Test de l'existence de la table *lignes* (si elle existe, on la détruit et on la recrée)
la table *lignes* contient les coordonnées GPS nettoyées et spatialisées
```{r echo=FALSE, warning=FALSE}
if (dbExistsTable(conn = con, "lignes") == TRUE)
{
  dbRemoveTable(conn = con, "lignes")
}

#Creation d'une table qui va recevoir les données GPS
dbSendQuery(conn = con, statement = read_file('Scripts\\06-Create Table lignes.sql'))
```

Spatialisation de la table *lignes*
-ajout d'une colonne geometrique
-insertion des données
-mise à jour de la colonne spatiale
-création d'un index spatiale
```{r echo=FALSE, warning=FALSE}
#creation de la colonne spatiale
dbSendQuery(conn = con, statement = read_file('Scripts\\07-AddGeometryColumn.sql'))

#Insertion des données dans la table
dbSendQuery(conn = con, statement = read_file('Scripts\\08-Insert Into.sql'))

#Mise a jour de la colonne geospatiale
dbSendQuery(conn = con, statement = read_file('Scripts\\09-MAJ Colonne spatiale.sql'))

#Creation d'un index spatial
dbSendQuery(conn = con, statement = read_file('Scripts\\10-CreateSpatialIndex.sql'))
```


## Chargement des données de réparation
boucle sur le répertoire *Datasources* pour charger tous les fichiers csv dans une table temporaire
```{r echo=FALSE, warning=FALSE}
#listing de tous les fichiers csv se trouvant dans le repertoire Datasources
ListFile <- list.files(path = "Datasources\\", pattern = "*.csv")

#boucle sur les fichiers csv
for (i in 1:length(ListFile))
{
#on insere le contenu de chaque fichier csv dans une table portant son nom
  MonFichier <- read.csv(paste0("datasources\\", ListFile[[i]]), sep = ";")
  MaTable <- substr(ListFile[[i]],1,10)
  
  #Si la table existe, on la supprime avant
  if (dbExistsTable(con, MaTable) == TRUE)
  {
    dbRemoveTable(con, MaTable)
  }
  
  dbWriteTable(conn = con, 
               name = MaTable, 
               value = MonFichier, 
               row.names = FALSE)
}

rm(MonFichier)
rm(MaTable)
rm(i)
rm(ListFile)
```

création d'une table *DEFAUTS* qui va contenir les défauts des voies
```{r echo=FALSE, warning=FALSE}
#Creation d'une table DEFAUTS
#test de l'existence de la table lignes, si elle existe, on la détruit et on la recrée
if (dbExistsTable(conn = con, "DEFAUTS") == TRUE)
{
  dbRemoveTable(conn = con, "DEFAUTS")
}

dbSendQuery(conn = con, statement = read_file('Scripts\\11-Create Table Defauts.sql'))
```

Insertion dans la table defaut des données
```{r echo=FALSE, warning=FALSE}
#Insertion dans une table DEFAUTS (en éliminant les doublons)
dbSendQuery(conn = con, statement = read_file('Scripts\\12-Insert Into Defauts.sql'))
```
Nettoyage des données
- suppression des données hors ile de france
- suppression des années de pose < 1900
- suppression des données
- suppression des données hors fissuration (type classement)
- suppression des données hors fissuration (type defaut)
```{r echo=FALSE, warning=FALSE}
#dbSendQuery(conn = con, statement = read_file('Scripts\\13-Delete Ile de France.sql'))
#dbSendQuery(conn = con, statement = read_file('Scripts\\14-Delete Annee Pose.sql'))
#dbSendQuery(conn = con, statement = read_file('Scripts\\15-Delete Groupe UIC.sql'))
#dbSendQuery(conn = con, statement = read_file('Scripts\\16-Delete ID_TYPE_CLASSEMENT.sql'))
#dbSendQuery(conn = con, statement = read_file('Scripts\\17-Delete ID_TYPE_DEFAUT.sql'))
```


Creation d'index
```{r echo=FALSE, warning=FALSE}
#Creation d'index
dbSendQuery(conn = con, statement = read_file('Scripts\\18-Creation Index idx_ligne_pk.sql'))
dbSendQuery(conn = con, statement = read_file('Scripts\\19-Creation Index idx_ligne_metre.sql'))
```
Récupération des coordonnees GPS des defauts
```{r echo=FALSE, warning=FALSE}
#Mise à jour des colonnes Longitude et Latitude
dbSendQuery(conn = con, statement = read_file('Scripts\\20-MAJ Longitude Latitude.sql'))
```



création d'une colonne spatiale
```{r echo=FALSE, warning=FALSE}
#creation de la colonne spatiale
dbSendQuery(conn = con, statement = read_file('Scripts\\21-AddGeometryColumn.sql'))
```

Insertion des points géometrique des defauts
```{r echo=FALSE, warning=FALSE}
#Mise a jour de la colonne geospatiale
dbSendQuery(conn = con, statement = read_file('Scripts\\22-MAJ Colonne spatiale.sql'))
```

```{r echo=FALSE, warning=FALSE}
#Suppression des tables temporaire
dbSendQuery(conn = con, statement = read_file('Scripts\\23-Drop table.sql'))
dbSendQuery(conn = con, statement = read_file('Scripts\\24-Drop table.sql'))
```

```{r echo=FALSE, warning=FALSE}
#Creation d'une vue
#dbSendQuery(conn = con, statement = read_file('Scripts\\25-Create View DEFAUTS_WK.sql'))
```






### Reduction base
```{r echo=FALSE, warning=FALSE}
dbSendQuery(conn = con, "VACUUM")
```
#Traitement des données dans R
```{r echo=FALSE, warning=FALSE}
#Recupération des données de la table DEFAUT
M <- dbGetQuery(conn = con, statement = "select ID_DEFAUT,LIGNE,VOIE,METRE,ANNEE_POSE,PROFIL_RAIL,VITESSE,GROUPE_UIC,RAYON_COURBE,TYPE_CLASSEMENT,EMPLACEMENT,ANNEE_DECOUVERTE,AGE from DEFAUTS ") 

#fermeture de la connexion
dbDisconnect(con)  
rm(con)
rm(rs)
rm(sqldrv)
```

Traitement de la varaible VOIE pour en déduire la variable RANG

avant
|VOIE|RANG|
-----------
|2700(2)|   |
après
|VOIE|RANG|
-----------
|2700| 2 |

```{r echo=FALSE, warning=FALSE}

M3<-M

#creation du champ RANG et Voie_Bis
#RANG => VOIE
for (i in 1:nrow(M3)){
  M3$RANG[i]<-substr(M3$VOIE[i],regexpr(")", M3[i,"VOIE"])[1]-1,regexpr(")", M3[i,"VOIE"])[1]-1)
  M3$VOIE_bis[i]<-substr(M3$VOIE[i],1,regexpr(")", M3[i,"VOIE"])[1]-4)
}                          

M3[which(M3$RANG==""),"RANG"]<-1
M3[which(M3$VOIE_bis==""),"VOIE_bis"]<-M3[which(M3$VOIE_bis==""),"VOIE"]
rownames(M3)<-NULL
M3$LIGNE<-as.numeric(M3$LIGNE)
M3$RANG<-as.numeric(M3$RANG)
M3$VOIE_bis<-as.factor(M3$VOIE_bis)
```

Traitement de la variable PROFILS RAILS
```{r echo=FALSE, warning=FALSE}

# croisement avec les correspondances du fichier Profil_rail.csv
#chargement du fichier
PRofil_R <- read.csv2("datasources\\Profil_rail.csv", header=TRUE, sep = ";")

TAB<-sqldf("select M3.*,Profil
      FROM M3 left join PRofil_R
ON M3.PROFIL_RAIL=PRofil_R.PROFIL_RAIL
      ")

#TAB<-TAB[,c(1,2,21,5,6,23,8,10,12,13:17,20)]
names(TAB)
```

```{r echo=FALSE, warning=FALSE}
TAB<-TAB[,c("ID_DEFAUT","LIGNE","VOIE_bis","METRE","ANNEE_POSE","Profil","VITESSE","GROUPE_UIC","RAYON_COURBE","TYPE_CLASSEMENT","EMPLACEMENT","ANNEE_DECOUVERTE","AGE","RANG")]
```
# mail
# clement.turbelin@upmc.fr
transformer l'age en segment
```{r echo=FALSE, warning=FALSE}
# transforer l'age en segment
TAB$AGE_bis<-cut(TAB$AGE,breaks = c(-10,0,10,20,30,40,50,60,70,80,90,200))
```

transformer la vitesse en segment
```{r echo=FALSE, warning=FALSE}
# transforer la vitesse en segment
TAB$VITESSE_bis <- cut(TAB$VITESSE,breaks = c(-10,0,50,100,160,200,400))
```

transformer la courbe en segment
OUI => Courbe
NON => Ligne Droite
```{r echo=FALSE, warning=FALSE}
TAB$COURBE <- sqldf('SELECT CASE WHEN RAYON_COURBE = 0 THEN "NON" WHEN 0 < RAYON_COURBE < 1200 THEN "OUI" ELSE "NON" END AS COURBE FROM TAB')
```

##fermeture de la connexion et nettoyage des variables
```{r echo=FALSE, warning=FALSE}
rm(PRofil_R)
rm(M)
rm(M3)
rm(i)
```
